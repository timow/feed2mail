#!/usr/bin/python

import argparse, ConfigParser, datetime, feedparser
import logging, os, smtplib, subprocess, sys, time, yaml
from email.mime.text import MIMEText

def load_config(path):
    global config
    config = ConfigParser.SafeConfigParser()
    read_config = config.read([path])

    if len(read_config) != 1:
        logging.critical('couldn\'t read config file \'%s\'', path)
        raise Exception('couldn\'t read config file \'%s\'' % path)

    logging.debug('using config file \'%s\'', read_config[0])

def load_database():
    global db
    path = config.get('DEFAULT', 'db_path')
    try:
        f = open(os.path.expanduser(path), 'r')
        db = yaml.safe_load(f)
        f.close()
    except:
        logging.warning('couldn\'t read database file')
        db = {}

def save_database():
    path = config.get('DEFAULT', 'db_path')
    try:
        f = open(os.path.expanduser(path), 'w')
        yaml.dump(db, f, default_flow_style = False)
        f.close()
    except:
        logging.critical('couldn\'t write database file')
        raise Exception('couldn\'t write database file')

def send_mail(feed_id, msg):
    # TODO check whether feed overrides defaults
    sender = config.get('DEFAULT', 'from')
    receiver = config.get('DEFAULT', 'to')
    host = config.get('DEFAULT', 'smtp_host')
    port = config.get('DEFAULT', 'smtp_port')

    s = smtplib.SMTP(host = host, port = port)
    s.sendmail(sender, receiver, msg.as_string())
    s.quit()

def markdown(html):
    p = subprocess.Popen([config.get('DEFAULT', 'pandoc_path'),
        '--from=html',
        '--to=markdown'],
            stdin = subprocess.PIPE,
            stdout = subprocess.PIPE,
            stderr = subprocess.PIPE)

    return p.communicate(html.encode('utf-8'))

def entry_id(entry):
    if not entry.has_key('id') and not entry.has_key('link'):
        return None
    return str(entry.id) if entry.has_key('id') else str(entry.link)

def new_feed_entries(feed_id, feed):
    for entry in feed.entries:
        eid = entry_id(entry)

        if not eid:
            logging.error('feed \'%s\' has entries without id and link',
                    feed_id)
            continue

        # new feed?
        if not db.has_key(feed_id):
            yield entry
        # new entry?
        elif not db[feed_id].has_key(eid):
            yield entry
        # entry updated?
        elif entry.has_key('updated_parsed'):
            last_updated = datetime.datetime.fromtimestamp(
                time.mktime(entry.updated_parsed))
            last_seen = datetime.datetime.strptime(
                db[feed_id][eid], "%Y-%m-%dT%H:%M:%S")
            if last_seen < last_updated:
                yield entry

def remember_entries(feed_id, feed):
    db[feed_id] = {}

    if feed.has_key('updated_parsed'):
        fallback_timestamp = feed.updated_parsed
    elif feed.has_key('published_parsed'):
        fallback_timestamp = feed.published_parsed
    else:
        fallback_timestamp = time.gmtime()

    for entry in feed.entries:
        eid = entry_id(entry)
        if not eid:
            continue

        if entry.has_key('updated_parsed'):
            entry_timestamp = entry.updated_parsed
        elif entry.has_key('published_parsed'):
            entry_timestamp = entry.published_parsed
        else:
            entry_timestamp = fallback_timestamp

        db[feed_id][eid] = datetime.datetime.fromtimestamp(
                time.mktime(entry_timestamp)).isoformat()

    save_database()

def mail(feed_id, feed, entry):
    # TODO check whether feed overrides defaults
    sender = config.get('DEFAULT', 'from')
    receiver = config.get('DEFAULT', 'to')

    text = feed.feed.title.encode('utf-8') \
            if feed.has_key('feed') and feed.feed.has_key('title') \
            else "".encode('utf-8')

    if entry.has_key('author'):
        text += " / " + entry.author.encode('utf-8')

    md_summary = markdown(entry.summary if entry.has_key('summary') else '')

    if bool(md_summary[1]):
        logging.error(md_summary[1])
        
    text += "\r\n"*2 + md_summary[0]
    
    if entry.has_key('link'):
        text += "\r\n" + entry.link.encode('utf-8')

    msg = MIMEText(text, _charset = 'utf-8')

    if entry.has_key('title'):
        msg["Subject"] = "[%s] %s" % (feed_id.encode('utf-8'), entry.title.encode('utf-8'))
    else:
        msg["Subject"] = "[%s] New feed" % (feed_id.encode('utf-8'))

    msg["From"] = sender
    msg["To"] = receiver

    return msg

if __name__ == '__main__':
    # parse cmd line
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument('--log',
        help = 'log level (debug, info, warning, error, critical)')
    arg_parser.add_argument('--config', help = 'path to config file')
    args = arg_parser.parse_args()

    # configure logging
    numeric_log_level = getattr(logging,
        args.log.upper() if args.log else "INFO", None)
    logging.basicConfig(format = '%(levelname)s: %(message)s',
        level = numeric_log_level)

    try:
        # load config
        load_config(args.config \
            if args.config 
            else os.path.expanduser('~/.feed2mailrc'))

        # load database
        load_database()
    except:
        sys.exit(1)

    # fetch and mail new entries of all feeds
    for feed_id in config.sections():
        logging.info('parsing feed \'%s\'', feed_id)
        feed = feedparser.parse(config.get(feed_id, 'url'))

        if feed == None or not feed.has_key('status'):
            logging.error('couldn\'t fetch feed \'%s\'', feed_id)
            continue

        if feed.status / 100 == 4:
            logging.error('feed \'%s\' returned status code %s',
                    feed_id, feed.status)
        else:
            logging.debug('feed \'%s\' returned status code %s',
                    feed_id, feed.status)
            for entry in new_feed_entries(feed_id, feed):
                send_mail(feed_id, mail(feed_id, feed, entry))
            remember_entries(feed_id, feed)
